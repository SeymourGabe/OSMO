# Module for processing image before giving it to LTT. Charlie Rackson.
import numpy as np
import copy


def padForTomo(A):
    """
    Takes array A, -> mininally zero-pads so square A1, -> zero pads to A2 so 
    that if A1 spun, the corners of A1 would just fit inside A2.
    
    IN:  2D array, probably generated by "imread"-ing an image
    
    OUTS:
            paddedArray: A zero padded square array s.t. the original array could spin
            without hitting the edges of the new array
            
            edgeSize:  the side-length of the square output array
            
            indsImgEdge:  the indicies of A1 within A2 (see above fxn description)
    """    
    

    S = A.shape
    Y = S[0]  #Num rows
    X = S[1]  #Num cols
    

    temp = A
    #--------- First padd the original array, just enough so that it's square----- 
    nColsPreAdded = 0
    nColsPostAdded = 0
    nRowsPreAdded = 0
    nRowsPostAdded = 0
    if Y != X:
        if Y > X: #If there are more rows than columns
            nxToAdd = Y-X
            if np.mod(nxToAdd,2)==0: #If num cols to add is even
                temp = np.pad(A, [ (0,0) ,(nxToAdd//2,nxToAdd//2)], 'constant')
                nColsPreAdded = nxToAdd//2
                nColsPostAdded = nxToAdd//2
            else: #num cols to add is odd
                temp = np.pad(A, [(0,0),(nxToAdd//2,nxToAdd//2+1)], 'constant')
                nColsPreAdded = nxToAdd//2
                nColsPostAdded = nxToAdd//2 + 1
        else: #Else there are more columns than rows
            nyToAdd = X-Y
            if np.mod(nyToAdd,2)==0: #If num rows to add is even
                temp = np.pad(A, [(nyToAdd//2,nyToAdd//2),(0,0)], 'constant')
                nRowsPreAdded = nyToAdd//2
                nRowsPostAdded = nyToAdd//2
            else: #Else the num rows to add is odd
                temp = np.pad(A, [(nyToAdd//2,nyToAdd//2+1),(0,0)], 'constant')
                nRowsPreAdded = nyToAdd//2
                nRowsPreAdded = nyToAdd//2+1
    #--------- Now temp is the smallest possible square array
                
                
    A = temp
    S = A.shape
    X = S[1]  #Num cols
    
    R = np.sqrt(2)*X/2
    NtoAddPerSide = int(np.ceil(R)-X/2)

    
    paddedArray = np.pad(A,NtoAddPerSide)
    
    edgeSize = X + 2*NtoAddPerSide
    
    #  ----------Find the indicies of the edges of the original image
    temp = np.zeros([edgeSize,edgeSize])

    temp[NtoAddPerSide+nRowsPreAdded,  NtoAddPerSide+nColsPreAdded:-NtoAddPerSide-nColsPostAdded] = 1        #Top of img
    temp[-NtoAddPerSide-1-nRowsPostAdded,  NtoAddPerSide+nColsPreAdded:-NtoAddPerSide-nColsPostAdded] = 1    #Bottom of img
    temp[NtoAddPerSide+nRowsPreAdded:-NtoAddPerSide-nRowsPostAdded,  NtoAddPerSide+nColsPreAdded] = 1        #Left side vertical line
    temp[NtoAddPerSide+nRowsPreAdded:-NtoAddPerSide-nRowsPostAdded,  -1-NtoAddPerSide-nColsPostAdded] = 1    #Right side vertical line

    indsImgEdge = np.array(np.nonzero(temp))
    # -------------Done finding the edges of the original image
    
    
    return paddedArray, edgeSize, indsImgEdge
    



def padForTomo3D_v0(A,percentVertPad):
    
    #This is how I think it should work. The size that's spin get padded as in the 2D case, then the top and bottoms get a little
    #exra, just to leave room to show unwanted gellation. 
    # However, this returns the error: 
    
    
    #   File "C:\Users\chra3427\Google Drive\---- Research ----\01 VAM via Python\tomosynthesis_withInhibition.py", line 413, in <module>
    #     retVal = LTT.setAllReconSlicesZ(fT);          #put target, f, into volume data slot

    #   File "C:\LTT\LTT_Windows_v1.6.12\python\LTTserver.py", line 1105, in setAllReconSlicesZ
    #     retVal = self.libLTT.setReconSlicesZ(ind, ind+3, fourSlices, dataSize, whichSCT)

    # ArgumentError: argument 3: <class 'TypeError'>: array must have flags ['C_CONTIGUOUS']
    
    S = A.shape
    Z = S[0]  #Num slices
    X = S[1]  #Num rows
    Y = S[2]  #Num cols
    
    temp = copy.copy(A)
    #--------- First padd the original array, just enough so that it's square in the spun direction----- 
    nColsPreAdded = 0
    nColsPostAdded = 0
    nRowsPreAdded = 0
    nRowsPostAdded = 0
    if Y != X:
        if Y > X: #If there are more rows than columns
            nxToAdd = Y-X
            if np.mod(nxToAdd,2)==0: #If num cols to add is even
                temp = np.pad(A, [ (0,0) ,(0,0) ,(nxToAdd//2,nxToAdd//2)], 'constant')
                nColsPreAdded = nxToAdd//2
                nColsPostAdded = nxToAdd//2
            else: #num cols to add is odd
                temp = np.pad(A, [(0,0) ,(0,0),(nxToAdd//2,nxToAdd//2+1)], 'constant')
                nColsPreAdded = nxToAdd//2
                nColsPostAdded = nxToAdd//2 + 1
        else: #Else there are more columns than rows
            nyToAdd = X-Y
            if np.mod(nyToAdd,2)==0: #If num rows to add is even
                temp = np.pad(A, [(0,0) ,(nyToAdd//2,nyToAdd//2),(0,0)], 'constant')
                nRowsPreAdded = nyToAdd//2
                nRowsPostAdded = nyToAdd//2
            else: #Else the num rows to add is odd
                temp = np.pad(A, [(0,0) ,(nyToAdd//2,nyToAdd//2+1),(0,0)], 'constant')
                nRowsPreAdded = nyToAdd//2
                nRowsPreAdded = nyToAdd//2+1
    #--------- Now temp is the smallest possible square array
                
    A = copy.copy(temp)            
    Snew = A.shape
    X = Snew[2]  #Num cols
    
    R = np.sqrt(2)*X/2
    NtoAddPerSide = int(np.ceil(R)-X/2)

    
    sidePaddedArray = np.pad(A,[(0,0), (NtoAddPerSide,NtoAddPerSide), (NtoAddPerSide,NtoAddPerSide)])
    
    
    NtoAddtoBothTopAndBottom = int(Z*percentVertPad)
    paddedArray = np.pad(sidePaddedArray, [(NtoAddtoBothTopAndBottom,NtoAddtoBothTopAndBottom), (0,0), (0,0)])
    
    
    sideEdgeSize = X + 2*NtoAddPerSide
    
    # #  ----------Find the indicies of the edges of the original image
    # temp = np.zeros([edgeSize,edgeSize])

    # temp[NtoAddPerSide+nRowsPreAdded,  NtoAddPerSide+nColsPreAdded:-NtoAddPerSide-nColsPostAdded] = 1        #Top of img
    # temp[-NtoAddPerSide-1-nRowsPostAdded,  NtoAddPerSide+nColsPreAdded:-NtoAddPerSide-nColsPostAdded] = 1    #Bottom of img
    # temp[NtoAddPerSide+nRowsPreAdded:-NtoAddPerSide-nRowsPostAdded,  NtoAddPerSide+nColsPreAdded] = 1        #Left side vertical line
    # temp[NtoAddPerSide+nRowsPreAdded:-NtoAddPerSide-nRowsPostAdded,  -1-NtoAddPerSide-nColsPostAdded] = 1    #Right side vertical line

    # indsImgEdge = np.array(np.nonzero(temp))
    # # -------------Done finding the edges of the original image
    
    
    
    

    return paddedArray, sideEdgeSize


def padForTomo3D(V):
    """
    Takes array A, -> mininally zero-pads so square A1, -> zero pads to A2 so 
    that if A1 spun, the corners of A1 would just fit inside A2.
    
    IN:  2D array, probably generated by "imread"-ing an image
    
    OUTS:
            paddedArray: A zero padded square array s.t. the original array could spin
            without hitting the edges of the new array
            
            edgeSize:  the side-length of the square output array
            
            indsImgEdge:  the indicies of A1 within A2 (see above fxn description)
    """    
    
    S = V.shape
    X = S[0]  #Num rows
    Y = S[1]  #Num cols
    Z = S[2]  #Num slices
    
    E = max(S)  #Largest edge size of original object
    temp = V
    #--------- First padd the original array, just enough so that it's square----- 
    
    if X != E or Y != E or Z != E:   #If the original volume isn't a cube
        newVol = np.zeros([E,E,E])
        delX = E-X
        delY = E-Y
        delZ = E-Z
        
        if delX == 0:
            xind0 = 0
            xind1 = E
        elif np.mod(delX,2)==0: # If num x pages to add is even
            xind0 = int(delX/2)
            xind1 = int(E-delX/2)
        else:               # If num x pages to add is odd
            xind0 = int(delX//2)
            xind1 = int(E-(delX//2+1))
            
            
        if delY == 0:
            yind0 = 0
            yind1 = int(E)
        elif np.mod(delY,2)==0: # If num y pages to add is even
            yind0 = int(delY/2)
            yind1 = int(E-delY/2)
        else:               # If num y pages to add is odd
            yind0 = int(delY//2)
            yind1 = int(E-(delY//2+1))
            
        if delZ == 0:
            zind0 = 0
            zind1 = int(E)
        elif np.mod(delZ,2)==0: # If num Z pages to add is even
            zind0 = int(delZ/2)
            zind1 = int(E-delZ/2)
        else:               # If num z pages to add is odd
            zind0 = int(delZ//2)
            zind1 = int(E-(delZ//2+1))
        
        newVol[xind0:xind1,yind0:yind1,zind0:zind1] = V
        temp = newVol   
            
        #--------- Now temp is the smallest possible cube array, with Edge-size E
                
                
    V = temp
    
    R = np.sqrt(3)*E/2  #Radius of sphere that encloses cube of side-length E
    NtoAddPerSide = int(np.ceil(R)-E/2)



    
    paddedArray = np.pad(V,NtoAddPerSide)
    
    
    edgeSize = E + 2*NtoAddPerSide
    
    # temp = np.zeros([edgeSize,edgeSize])

    # temp[NtoAddPerSide+nRowsPreAdded,  NtoAddPerSide+nColsPreAdded:-NtoAddPerSide-nColsPostAdded] = 1        #Top of img
    # temp[-NtoAddPerSide-1-nRowsPostAdded,  NtoAddPerSide+nColsPreAdded:-NtoAddPerSide-nColsPostAdded] = 1    #Bottom of img
    # temp[NtoAddPerSide+nRowsPreAdded:-NtoAddPerSide-nRowsPostAdded,  NtoAddPerSide+nColsPreAdded] = 1        #Left side vertical line
    # temp[NtoAddPerSide+nRowsPreAdded:-NtoAddPerSide-nRowsPostAdded,  -1-NtoAddPerSide-nColsPostAdded] = 1    #Right side vertical line


    # indsImgEdge = np.array(np.nonzero(temp))

    
    return paddedArray, edgeSize


def padForTomo3DWRONG(A,percentVertPad):
    
    #Pads input ZXY array to the smallest possible cube-shaped array
    
    #Input array, A, is in format: [slices, X, Y]
    
    # First makes sides square
    # - compute which is largest: the reultant corer radius, or the (height + a little extra)
    # - Whichever dim is largest, pad to a cube.
    
    # This is more padded than is needed, but I think it avoids the issue of the LTT error shown below, which results when array isn't a cube
    
    
    #   File "C:\Users\chra3427\Google Drive\---- Research ----\01 VAM via Python\tomosynthesis_withInhibition.py", line 413, in <module>
    #     retVal = LTT.setAllReconSlicesZ(fT);          #put target, f, into volume data slot

    #   File "C:\LTT\LTT_Windows_v1.6.12\python\LTTserver.py", line 1105, in setAllReconSlicesZ
    #     retVal = self.libLTT.setReconSlicesZ(ind, ind+3, fourSlices, dataSize, whichSCT)

    # ArgumentError: argument 3: <class 'TypeError'>: array must have flags ['C_CONTIGUOUS']
    
    # if np.mod(A.shape[0],2): #if we have an odd number of slices, add a zero slice
    #     A = np.pad(A,[(1,0),(0,0),(0,0)]) #Adds a slice containing zeros to the top
        
    
    S = A.shape
    Z = S[0]  #Num slices
    X = S[1]  #Num rows
    Y = S[2]  #Num cols
    
    temp = copy.copy(A)
    #--------- First padd the original array, just enough so that it's square in the spun direction----- 
    nColsPreAdded = 0
    nColsPostAdded = 0
    nRowsPreAdded = 0
    nRowsPostAdded = 0
    if Y != X:
        if Y > X: #If there are more rows than columns
            nxToAdd = Y-X
            if np.mod(nxToAdd,2)==0: #If num cols to add is even
                temp = np.pad(A, [ (0,0) ,(0,0) ,(nxToAdd//2,nxToAdd//2)], 'constant')
                nColsPreAdded = nxToAdd//2
                nColsPostAdded = nxToAdd//2
            else: #num cols to add is odd
                temp = np.pad(A, [(0,0) ,(0,0),(nxToAdd//2,nxToAdd//2+1)], 'constant')
                nColsPreAdded = nxToAdd//2
                nColsPostAdded = nxToAdd//2 + 1
        else: #Else there are more columns than rows
            nyToAdd = X-Y
            if np.mod(nyToAdd,2)==0: #If num rows to add is even
                temp = np.pad(A, [(0,0) ,(nyToAdd//2,nyToAdd//2),(0,0)], 'constant')
                nRowsPreAdded = nyToAdd//2
                nRowsPostAdded = nyToAdd//2
            else: #Else the num rows to add is odd
                temp = np.pad(A, [(0,0) ,(nyToAdd//2,nyToAdd//2+1),(0,0)], 'constant')
                nRowsPreAdded = nyToAdd//2
                nRowsPreAdded = nyToAdd//2+1
    #--------- Now temp is the smallest possible square array, a viewed in a single Z-slice
                
    A = copy.copy(temp)            
    Snew = A.shape
    side = Snew[2]                         #Num cols - the side length of a new square Z-slice
    
    
    minR = np.ceil(np.sqrt(2)*side/2)         #This is the minimum half size length of the final cube array, as forced by Z-slice radius
    minHr = np.ceil(Z*(1+percentVertPad)/2)   #This is the minimum half side length of the final cube array, as forced by structure height
    
    
    if minR >= minHr:
        R = copy.copy(minR)
    else:
        R = copy.copy(minHr)
    
    
    NtoAddPerSide = int(np.ceil(R)-X/2)
    
    
    
    
    if R>=H:
        NtoAddPerSide = int(np.ceil(R)-X/2)
        NtoAddtoBothTopAndBottom = int(np.ceil(R)-Z/2)
    else: #Else the padded array is driven in size be height
        NtoAddPerSide = int(H/2-X/2)
        NtoAddtoBothTopAndBottom = int(H/2-Z/2)
    
    # sidePaddedArray = np.pad(A,[(0,0), (NtoAddPerSide,NtoAddPerSide), (NtoAddPerSide,NtoAddPerSide)])   
    # NtoAddtoBothTopAndBottom = int(Z*percentVertPad)
    
    paddedArray = np.pad(A, [(NtoAddtoBothTopAndBottom,NtoAddtoBothTopAndBottom), (NtoAddPerSide,NtoAddPerSide), (NtoAddPerSide,NtoAddPerSide)])
    
    
    sideEdgeSize = X + 2*NtoAddPerSide
    
    # #  ----------Find the indicies of the edges of the original image
    # temp = np.zeros([edgeSize,edgeSize])

    # temp[NtoAddPerSide+nRowsPreAdded,  NtoAddPerSide+nColsPreAdded:-NtoAddPerSide-nColsPostAdded] = 1        #Top of img
    # temp[-NtoAddPerSide-1-nRowsPostAdded,  NtoAddPerSide+nColsPreAdded:-NtoAddPerSide-nColsPostAdded] = 1    #Bottom of img
    # temp[NtoAddPerSide+nRowsPreAdded:-NtoAddPerSide-nRowsPostAdded,  NtoAddPerSide+nColsPreAdded] = 1        #Left side vertical line
    # temp[NtoAddPerSide+nRowsPreAdded:-NtoAddPerSide-nRowsPostAdded,  -1-NtoAddPerSide-nColsPostAdded] = 1    #Right side vertical line

    # indsImgEdge = np.array(np.nonzero(temp))
    # # -------------Done finding the edges of the original image
    
    
    
    

    return paddedArray, sideEdgeSize


def prepIm4LTT(A,makeBinary):
    """
    Take array, normalized to [0,1], possibly force to be binary, pad with
    zeros, make 32-bit, and put into LTT format (Z,X,Y)

    Parameters
    ----------
    A : array
        Probably generated from image by imread.
        
    MakeBinary : bool
        True = force image to be 0s and 1s
        False = allow for grayscale

    Returns
    -------
    B : array
        Normalized
        
    edgeSize : array
        Side length of padded square array
        
    indsImgEdge: 
        indicies of the edge of the original square img within the padded array

    """
    if np.any(A):        #If A is nonzero
        A = A/A.max()    #Normalize to [0,1]
    
    if makeBinary:
        A[A<0.5]  = 0
        A[A>=0.5] = 1
        
    A1, edgeSize, indsImgEdge = padForTomo(A)  # Zero pad the array
    
    A2 = np.float32(A1)
    
    B = np.expand_dims(A2, axis=0)  #puts [x,y] img
    
    return B, edgeSize, indsImgEdge
    
    

    